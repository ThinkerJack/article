![](https://img-blog.csdnimg.cn/20210409225626596.png) 

# 0. 写在前面

本篇文章是《Dart教程》系列的第一篇，整个系列一共二十二篇文章。

![](https://img-blog.csdnimg.cn/2021040711425941.png)



## 0.1 创作的初心

笔者目前从事Flutter开发工作，在接触Flutter开发之前有一些JavaScript和Java的语言基础。众所周知，Flutte使用Dart语言开发，Dart吸收了很多现代语言的特性，笔者在初学的时候并没有遇到太大的困难。

但是，随着时间的推进，很多Dart语言高级特性的不甚理解逐渐成为了笔者深入学习Flutter的阻碍。笔者之前就有做笔记的习惯，一开始写了几篇Dart语言的笔记 ，在学习的过程中逐渐查缺补漏，对Dart语言也有了更全面的认识。笔者在网上寻找Dart相关学习资源的时候，发现成体系的中文Dart编程语言教程非常少，加上官网上的Dart教程不是特别详细，很多高级特性一带而过，逐渐萌生了写一个完整的成体系的Dart语言教程的想法。

自己学习之外，本着开源的精神，希望能为Flutter，Dart中文社区贡献自己的一份力量，打算把这份教程开源出来。决定开源之后对自己的文章就有了更高的要求，如何写出更易读，更易于理解的教程，同时也希望自己的教程能有一定的深度，分享一些自己在学习过程中遇到的疑问，也想分享一些自己从事Flutter工作以来一些使用Dart语言的技巧，这样就有了现在的这份Dart语言教程。

## 0.2 如何分享

大家在看到本篇文章的时候本系列的教程已经全部完成了，会通过每天更新一篇的方式在各大博客平台发布，同时也会分享在笔者的Github上，希望文章能给更多的Flutter，Dart初学者和想要了解更多的Dart语言特性的Flutter开发人员带来帮助。

同时文章会首发在笔者的微信公众号《思想者杰克》，如果你发现教程中有错误或者某些地方表述不清晰，对内容有疑惑，可以通过微信公众号添加作者微信，向作者反馈，如果教程确实有这样的问题，作者修改后，可以将你的名字加到教程的Github项目上。还可以通过微信公众号加入笔者的技术交流群，一起进步。

## 0.3 创作过程

学习Dart主要还是通过看官方文档，除了看官方文档外，还有阅读stackoverflow上的问题，官方的博客，还有各个博客网站上Dart相关的技术文章。创作的过程中尽量不直接使用别人文章里的原话或者图片，当然如果自己实在没想到更好的表达方式，也会进行引用。由于创作过程中看了很多的技术文章，没有办法一一标注引用。如果你在教程中发现引用了你的文章中的段落或者图片，欢迎通过微信公众号联系作者，作者可以将你的名字加到教程的Github项目上，当然这种原文引用是很少的，Dart官方的解释在基础教程中引用的比较多。

后续会把详细的学习过程和经验与大家分享，毕竟授人以鱼不如授人以渔。



> 本教程基于Dart SDK 2.12空安全版本。

# 1.重要概念



在学习 Dart 语言时, 应该基于以下事实和概念：

- 您可以在变量中放置的所有内容都是一个对象，每个对象都是一个类的实例。

  数字，函数都是对象。除了`null`。

  Dart中所有的对象都继承`Object`类。

- 尽管Dart是强类型的，但类型注释是可选的，可以使用`var`来声明变量，Dart可以自动推断类型。

- 默认情况下变量不能为`null`，除非您明确需要他可以为`null`。

  您可以通过在变量类型的末尾添加`?`来使该变量为可`null`值。

  例如，类型的变量`int?`即可以是整数，也可以是`null`。

  ```dart
  //示例1
  int? a;
  print(a);
  ```

  输出如下：

  > null

  如果您知道某个表达式永远不会是`null` ，但Dart编译检查无法通过，则可以添加`!`断言它不为`null`（如果是`null`，则抛出异常）。

  一个例子：`int x = nullableButNotNullInt!`。

  一段代码示例来展示声明变量时末尾加`!`和不加`!`的区别：

  ```dart
  //示例2.1
  var nullableButNotNullInt;
  int x = nullableButNotNullInt!;
  print(x);
  ```

  输出如下：

  > `Unhandled exception:`
  > `Null check operator used on a null value`

  如果不加`!`，输出如下：

  > `Unhandled exception:`
  > `type 'Null' is not a subtype of type 'int'`

- 如果您想明确地说允许使用任何类型，请使用该类型`Object?` 。如果你必须将类型检查推迟到运行时使用特殊类型`dynamic`。

- Dart支持泛型，例如`List<int>`（整数列表）或`List<Object>`（任何类型的对象列表）。

- Dart支持顶级函数（例如`main()`）以及属于类和对象的方法（分别为静态（`static`）方法和实例方法）。

  您也可以在函数内创建函数（嵌套函数或局部函数）。

  同样，Dart支持顶级变量以及属于类和对象的变量（静态（`static`）变量和实例变量）。实例变量有时称为字段或属性。

- Dart不具备像Java中`public`，`protected`和`private`这样的关键字。

  Dart定义私有通过标识符以`_`（下划线）开头。

  如果标识符以`_`（下划线）开头，则该字段，类或方法仅在定义它们的`.dart`文件中可用。

  注意：私有不是类级别，是声明他们的文件级别。

- Dart工具可以报告两种问题：警告和错误。

  警告只是表明您的代码可能无法运行，但它们并不能阻止您的程序执行。

  错误可以是编译时或运行时。编译时错误完全阻止了代码执行。运行时错误导致代码执行时引发异常。

# 2.变量声明

## 2.1 变量

### 2.1.1 简介

这是创建变量并对其进行初始化的示例：

```dart
var name = 'Bob' ; 
```

变量仅存储对象引用。以上代码为变量`name`包含对`String`类型的值为“ Bob”的对象的引用。

上面的代码中`name`变量的类型推断为`String`，但是您可以通过指定它来更改它的类型。

如果对象不限于单一类型，请指定`Object`类型（或在必要时使用`dynamic`）。

```dart
Object name = 'Bob';
```

另一个选择是显式声明将要推断的类型：

```dart
String name = 'Bob';
```

不要轻易使用`var`，使用`var`的时机请参考effective-dart。

*PS:简单看了下Flutter源代码，几乎没有`var`声明的变量。*

### 2.1.2 变量仅存储对象引用

一段代码示例来演示变量仅存储对象引用：

```dart
//示例3
class Test{
  int _num = 0;
}
void main(){
  var test1 = Test();
  var test2 = Test();
  var a = test1;
  var b  = a;
  print(identical(b,test1));
  print(identical(b,test2));
  test1._num = 10;
  print(b._num);
}
```

*PS：`identical`函数：检查两个引用是否指向同一个对象。*

输出如下：

> true
> false
> 10

另一段代码示例来证明变量仅存储对象引用：

```dart
//示例4
void main(){
  var test = Test();
  changeValue(test);
  print(test._num);
}
class Test {
  int _num = 0;
}
void changeValue(Test data) {
  print(data._num);
  data._num = 10;
}
```

输出如下：

> 0
> 10

看了上面两个例子，你应该已经理解Dart中变量仅存储对象引用的含义了。

## 2.2 默认值

可为空的未初始化变量默认值为`null`。

如果启用空安全，则必须在使用非空变量之前对其进行初始化。

换句话说，您不必在声明该变量时进行初始化，但是你需要在使用它之前进行初始化。

例如，以下代码是正确的，因为当`lineCount`传递给`print()`时，Dart可以检测到`lineCount`是非空的：

```dart
//示例5
int lineCount;

if (true) {
  lineCount = 1;
} else {
  lineCount = 0;
}
  
print(lineCount);
```

## 2.3 late修饰符

Dart 2.12版本添加了`late`修饰符，该修饰符有两个作用：

- 声明一个在声明后初始化的，不能为空的变量。
- 延迟初始化变量。

如果您确定在使用变量之前已设置了变量，但无法通过Dart的编译时检查，则可以通过将变量标记为`late`来修复错误：

```dart
//示例6
late String test;

void main() {
  test = 'Freida!';
  print(test);
}
  
```

 如果未能初始化`late`变量，则使用该变量时会发生运行时错误。

如果将变量标记为`late`，但在声明时对其进行初始化，那么初始化程序将在变量第一次使用时运行。

这种延迟初始化在以下几种情况下是很方便的:

- 可能不会用到该变量，并且初始化它的成本很高。
- 您正在初始化实例变量，并且其初始值设定项需要访问`this`。

在以下示例中，如果从未使用过`temperature`变量，则永远不会调用开销很大的函数`_readThermometer()`：

```dart
late String temperature = _readThermometer(); // 延迟初始化
```

## 2.4 final

如果您从不打算更改变量，请使用`final`或`const`代替`var`或其他类型。`final`修饰的变量只能设置一次。`final`修饰的顶级变量或类变量（静态变量）在首次使用时被初始化。

这是创建和设置`final`变量的示例：

```dart
//示例7
final name = 'Bob'; // final修饰的变量可以没有类型注解
final String nickname = 'Bobby';
```

您不能更改`final`变量的值：

```dart
name = 'Alice'; // 错误:final变量只能设置一次。
```

## 2.5 const

### 2.5.1 简介

 如果你想要编译时常量，使用`const`。

`const`修饰的变量在编译时就已经固定（`const`变量隐式为`final`），也就意味着`const`修饰的变量必须在声明时进行初始化，例如`const list = [1]`。

如果想用`const`修饰类变量，则将其标记为`static const`。

使用`const`关键字需要在声明变量的地方，将**值**设置为编译时常量，编译时常量类型有很多，例如数字或字符串，`const`变量或对常量进行算术运算：

```dart
//示例8
const num = 1000000;
const atm = 1.5 * num;
```

该`const`关键字不仅仅可以用来声明常数变量。您还可以使用它来创建常量值，以及声明创建常量值的构造函数。任何变量都可以具有常量值。

```dart
var foo = const [];
final bar = const [];
const baz = []; //等同于const []
```

可以在`const`声明的初始化表达式中省略`const`，就像上面的baz那样。

您可以更改不是用`final`或`const`修饰的变量，即使该变量的**值**是`const`变量：

```dart
foo = [1, 2, 3];//正确
```

您不能更改`const`变量的值：

```dart
baz = [ 42 ]; //错误：无法为常量变量分配值。  
```

您可以定义使用类型检查和强制类型转换（`is`和`as`）， 集合内使用`if`和扩展运算符（`...`和`...?`）的常量 ：

```dart
const Object i = 3; 
const list = [i as int]; 
const map = {if (i is int) i: "int"}; 
const set = {if (list is List<int>) ...list}; 
       
```

如果声明了一个`const`集合，则其中的所有内容也必须递归地为`const`。

`const`不能修饰类的实例（instance）变量。

>   注意：尽管`final`修饰的对象无法重新赋值，但是可以更改对象的字段。相比之下，`const`对象及其字段不能更改：它们是不可变的。

### 2.5.2  所有内容相同的const变量都是同一个对象

关于`const`还有一个有趣且重要的知识点:

`const`修饰的相同的变量存储的引用都一致，换句话说所有内容相同的`const`变量都是同一个对象。

对于任何给定的`const`变量，无论对`const`表达式求值多少次，都将重用单个`const`对象。

有点难读是吧，一段代码示例来向你展示这句话的含义：

```dart
//示例9.1
const a = [1, 2];
const b = [1, 2];
print(identical(a, b));
```

输出如下：

> true

为了区别`const`变量和普通变量的区别，再来看一段例子：

```dart
//示例9.2
var a = [1, 2];
var b = [1, 2];
print(identical(a, b));
```

> false

### 2.5.3 创建不可变对象

`const`可以使**对象不可变**。为了使一个类的对象不可变，我们需要在**构造函数中使用const关键字，**并将**所有字段都设置为final，**如下所示：

```dart
//示例10
class A {
  final a, b;

  const A(this.a, this.b);
}
```

```dart
var a = A(1, 2);
```

a对象就是不可变的对象。使用`const`修饰类的构造函数还有一个好处，我们可以在声明变量的时候在值上添加`const`:

```dart
var a = const A(1, 2);
```

声明变量的时候在值上添加`const`可以避免重复创建相同对象浪费内存。

*PS:在Flutter源代码中，我们可以看到所有的`widget`都是不可变对象。同样我们在使用某些可以在编译之前确定属性的widget时，用const创建是更好的做法，避免重复创建相同对象浪费内存。*

# 3. 课后练习

## 3.1 课后练习的目的和意义

课后练习，一是对文章的一些重要概念进行总结，通过问题和回答的方式加深大家的记忆。二是看一看大家是不是理解了文章中的内容。

很多朋友喜欢背面试题，课后练习在某种程度上可以称的上是面试题，有一些问题也是笔者在面试过程中收集的Dart面试题，但绝不推荐大家背面试题，也不推荐大家直接跳过文章内容看课后练习。本系列文章用了很多的代码示例来直观的展示概念是如何实际应用的，用代码来验证文中所说内容。"Talk is cheap. Show me the code"，你可以在[github](https://github.com/jack0-0wu/dart_demo)上下载作者上传的代码示例运行一下，也可以自己搭建环境编写代码试一试，看看代码实际运行起来和概念所说的是否一致。

## 3.2 Dart _私有的级别？

声明当前变量的文件。

## 3.3 Dart是值传递还是引用传递？

引用传递。

## 3.4 Dart中哪些变量是延迟初始化的？如何将成员变量延迟初始化？

顶级变量，类变量（`static`）。

使用`late`关键字初始化成员变量。

*PS：之前的文章中我们有这样一句话"`final`修饰的顶级变量或类变量（静态变量）在首次使用时被初始化。"，其实顶级变量和类变量（`static`）本身就是延迟初始化的，`final`关键字只是没有影响顶级变量和类变量本身就有的延迟初始化的功能，并非是`final`关键字赋予了顶级变量和类变量延迟初始化的功能。`late`关键字也是同理，`late`和`final`有区别的一点是，`late`可以让本身不是延迟初始化的成员变量变成延迟初始化。*

*多说一句，`const`作为编译时常量，会影响顶级变量和类变量本身就有的延迟初始化的功能。这个问题上面没有讲，答不上来也正常，后续顶级变量应该也不会再写了，如果不知道这个容易形成误区，所以把这个知识加到这里。*

## 3.5 Dart final和const的共同点和区别？

1.共同点：

- 都是声明常量，初始化后不能再赋值。
- 声明的类型可以省略。

2.区别：

final:

- 运行时常量，可以初始化一次。
- 不影响顶级变量和类变量的延迟初始化功能。
- 可以修饰可变对象。
- 可以修饰实例（instance）变量。

const:

- 编译时常量，声明时必须进行初始化。
- 用`const`修饰的顶级变量和类变量不能延迟初始化，编译时就进行初始化。
- 不可以修饰可变对象。
- 不可以修饰实例（instance）变量。

## 3.6 Dart如何创建不可变对象？

使用`const`修饰类的构造方法，使用`final`修饰类里的所有属性。

# 4.文中示例

文中的所有代码示例都在作者的[Github](https://github.com/jack0-0wu/dart_demo)上。

找到文章对应的dart文件，本文对应的是01.dart，每个示例上都有标号的备注，将注释取消就可以运行了。

![](https://img-blog.csdnimg.cn/20210410112845538.png)

